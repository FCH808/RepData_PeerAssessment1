# Reproducible Research: Peer Assessment 1
========================================================

## Loading and preprocessing the data

```{r, echo=FALSE}
require(data.table)
require(ggplot2)
require(lubridate)
require(RColorBrewer)
```

```{r}
#url<- "https://d396qusza40orc.cloudfront.net/repdata%2Fdata%2Factivity.zip"
#download.file(url, "activity.zip")
#closeAllConnections()
unzip("activity.zip", "activity.csv") 
active<- fread("activity.csv")
active$date<-as.Date(active$date)
# Lubridate's wday function can fill in the Weekday's full names as ordered factor variables. Sun to Sat.
# Create a column of these days of the week for each date for subsetting.
active$weekday<-wday(active$date, label = TRUE, abbr = FALSE)

#Quick look at the data
active
```

## What is mean total number of steps taken per day?



```{r fig.width=14, fig.height=8}
# Create function which takes the active dataframe, and an RBrewers color scheme for customization. 

# Color scheme defaults to "Greens"

# Weekend are colored the same dark color to identify better. 

# Weekdays start light on Monday and gradually get darker as they approach the weekend.

# Creates a plot which:

# 1.) Makes a histogram of the total number of steps taken each day

# 2.) Calculates and reports the mean and median total number of steps taken per day

make.sums.ggplot<- function(active.dataframe, RBrewers.colors = "Greens"){
  
  #Transmform the data and get averages.
  
  #Sum up all the variables of the data.frame/data.table, grouped by date
  active.sums<-active.dataframe[ , lapply(.SD, sum), by = date]
  # Add our weekdays back in
  active.sums$steps<- round(active.sums$steps, 2)
  active.sums$weekday<-wday(active.sums$date, label = TRUE, abbr = FALSE)
  head(active.sums)  
  # Create a vector of brewer greens for representing the ordinal change from Monday to Sunday.
  
  # 7 is passed in because there are 7 factors: each day of the week.
  my.cols<- brewer.pal(7, RBrewers.colors)
  # Ordered factors start on Sunday. Rather than reordering the date factor variables, we can just reassign the color for Saturday to Sunday as well. This will make the weekends stand out.
  my.cols[1] <- my.cols[7]
  # Get max number of steps for largest interval for extending y-axis to fit labels.
  max.sum<-max(active.sums$steps, na.rm = TRUE)
  
  
  ggplot(active.sums, aes(x = date, y = steps, fill = weekday)) + geom_bar(stat = "identity") +
    scale_x_date(breaks="1 day", limits = as.Date(c('2012-10-03','2012-11-28'))) +
    theme(axis.text.x  = element_text(size=10,angle=45,colour="black",vjust=1,hjust=1)) + 
    scale_fill_manual(values = my.cols) + 
    geom_text(aes(x = date, y = steps, label = steps, angle  = 90, size = 5, hjust = -0.1), color = "white", show_guide  = F) + 
    theme(panel.grid.minor=element_blank(), panel.grid.major=element_blank()) +
    theme(panel.background=element_rect(fill="darkgrey")) + 
    coord_cartesian(ylim=c(0,max.sum*1.15)) +
    geom_hline(aes ( yintercept = mean(steps, na.rm = TRUE)), color = "chocolate3", size = 1.5, alpha = .50) + 
    geom_hline(aes ( yintercept = median(steps, na.rm = TRUE)), color = "darkred", alpha = .50) +
    geom_text(aes(label = paste("Mean =", round(mean(steps, na.rm = TRUE), 2) ), x = as.Date('2012-11-04'), y = 15600), color = "chocolate3", size = 4) +
    geom_text(aes(label = paste("Median = ", round(median(steps, na.rm = TRUE), 2) ), x = as.Date('2012-11-04'), y = 15000), color = "darkred", size = 4) +
    ylab("Total Steps taken per day") +
    xlab(NULL)
}

make.sums.ggplot(active, "Greens")

# 8 rows/days are missing and not plotted
```

## What is the average daily activity pattern?

```{r fig.width=13, fig.height=7}

# Create a function which:

# 1.) Makes a time series plot (i.e. type = "l") of the 5-minute interval (x-axis) and the average number of steps taken, averaged across all days (y-axis) This plotted in 5 minute intervals but labeled in 30 minute intervals to reduce labeling clutter.

# 2.) Reports the 5-minute interval, on average across all the days in the dataset, wihch contains the maximum number of steps

make.max.interval.ggplot<- function(active.dataframe){
  active.dataframe$times<- as.factor(sprintf("%02d:%02d", active.dataframe$interval%/%100, active.dataframe$interval%%100) )  
  active.intervals<- active.dataframe[ , mean(steps, na.rm = TRUE), by = times]
  
  setnames(active.intervals, c("Interval", "Average"))
  
  max.active<-active.intervals[which.max(active.intervals$Average),]
  max.interval<<- max.active$Interval[1]
  max.average<<- round(max.active$Average[1], 2)
  
  ggplot(active.intervals, aes(x = Interval, y = Average, group = 1)) + geom_line() +
    geom_text(aes(label = paste("Max Interval =", max.interval ), x = max.interval, y = max.average + 12), color = "black", size = 4) +
    geom_text(aes(label = paste("Max Interval Average Steps =", max.average ), x = max.interval, y = max.average + 4), color = "black", size = 4) + 
    theme(axis.text.x=element_text(angle=270,hjust=1,vjust=0.5, size = 10)) + 
    scale_x_discrete(breaks = active.intervals$Interval[seq(1,288, by = 6)]) +
    ylab("Average steps") + 
    xlab("5-minute Time Intervals (Labeled in chunks of 30-minutes)") +
    theme(legend.position="none")
}

make.max.interval.ggplot(active)


```

## Imputing missing values

```{r}
# 1.) Calculate and report the total number of missing values in the dataset (i.e. the total number of rows with NAs)

# NA's :2304 
summary(active)
# Subset out all rows with an NA value, 2304 rows
NA.active<-subset(active, !complete.cases(active))
# All NAs are contained in 8 days, which have all steps missing for each day 
table(NA.active$date)
```


```{r}
# 2.) We will impute the values by filling in the mean of the steps in each interval. 

# For example, to fill in NA's on Monday's at 12:00, all "12:00 - 12:05" intervals for all Monday's will be used to get the imputed value.

# The same will be done for Tuesday's in this time period, etc. So that each unique day has different means in each time interval.

#Initial step:
# Create function that gets breakdown of an interval, by weekday
interval.summary<- function(active.dataframe, interval.number){
  for (i in unique(active.dataframe$interval)){
    for (j in unique(active.dataframe$weekday))
      if (i == interval.number) {print (summary(subset(active.dataframe, active$interval == i & active.dataframe$weekday == j)))       
      }
  }
}
# Here we show the max interval, 835
interval.summary(active, 835)
```

```{r}

# We can use this same process to get breakdowns of each interval for each weekday, and fill in the NAs with the mean of each interval depending on the day just in case there is a significant difference between intervals depending on the day of the week. (i.e. Weekends may differ from Weekdays)



impute.active<- function(active.dataframe){

  imputed<- active
  # Create an empty.frame with the same structure to append the imputed rows to. This is to rebuild the df, with the mean of each interval/weekday combination used to fill each NA.
  imputed<-imputed[which(is.na(imputed$text)), ]
  imputed
  
  for (i in unique(active$interval)){
    for (j in unique(active$weekday)){
      temp.df<- subset(active, active$interval == i & active$weekday == j)
      temp.mean<- mean(temp.df$steps, na.rm = TRUE)
      temp.df$steps[is.na(temp.df$steps)]<- temp.mean
      imputed<- rbind(imputed, temp.df)
    }
  }
  # http://stackoverflow.com/questions/1296646/how-to-sort-a-dataframe-by-columns-in-r
  imputed<-imputed[order(date,interval)]
  return(imputed)
}


# Pass the original database into the function and assign the resulting database with imputed values to "imputed"

# 3.) Create a new dataset that is equal to the original dataset but with the missing data filled in.

imputed<- impute.active(active)

```

```{r}

# Calling our previous function, the means, min and max, don't change, and now NA's are filled in.

#interval.summary(imputed, 835) #Not called in RMarkdown for brevity

#interval.summary(active, 835) #Not called in RMarkdown for brevity

## Needs docstring: Accepts (df, df, int, string) type combination

# Integrity check function to make sure imputation went as planned.
imputed.check<- function(original.df, imputed.df, check.interval, check.weekday) {
  print ("Original interval/day combination")
  print (subset(active, active$interval == check.interval & weekday == check.weekday))
  # Mean without the NAs for this interval/day combination is 225.8571
  temp.mean<-mean(subset(active, active$interval == check.interval & weekday == check.weekday)$steps, na.rm = TRUE)
  print (paste("Mean for original dataset without NAs is:", temp.mean))
  print ("")
  # This mean is filled into the NA slots, while the remaining values remain unchanged.
  print ("Imputed interval/day combination")
  print (subset(imputed, active$interval == check.interval & weekday == check.weekday))
}


# Integrity Check #1:
imputed.check(active, imputed, 835, "Monday")
# Quick check on the rows of all Mondays in interval 835 in the original set vs. the imputed set

# Mean without the NAs for this interval/day combination is 225.8571

# This mean is filled into the NA slots, while the remaining values remain unchanged.


# Integrity Check #2:
imputed.check(active, imputed, 1005, "Thursday")
# Quick check on the rows of all Thursday in interval 1005 in the original set vs. the imputed set. Zero is filled into this interval/day combination since it is all zeros.


# Integrity Check #3:
imputed.check(active, imputed, 1600, "Saturday")
# Quick check on the rows of all Thursday in interval 1600 in the original set vs. the imputed set. This value is filled in correctly as well.
```

```{r fig.height=8, fig.width=14}

#4.) Make a histogram of the total number of steps taken each day and Calculate and report the mean and median total number of steps taken per day.  

# Call our make.sums.ggplot to make a new plot with the imputed dataset

# The mean and median changed slightly since the missing/imputed days were fairly busy days in general in the dataset.
make.sums.ggplot(imputed, "Blues")


# Do these values differ from the estimates from the first part of the assignment?

# What is the impact of imputing missing data on the estimates of the total daily number of steps?

# The original averages for each day that wasn't NA remain unchanged, but new bars from the summation of averages of each interval of each day for now present.

# The overall values are slightly higher because the imputed days that were missing tended to be busier days of the week with more steps.


```

## Are there differences in activity patterns between weekdays and weekends?

```{r}
# 1.) Creates a new factor variable in the dataset with two levels - "weekday" and "weekend" indicating whether a given date is a weekday or weekend day.

# Function to add weekend/weekday factor to a dataframe that has a weekdays column

make.weekends<- function(active.df){
  active.df$weekend<- as.character(active.df$weekday)
  active.df$weekend[active.df$weekend == "Saturday"| active.df$weekend =="Sunday"]<- "Weekend"
  active.df$weekend[active.df$weekend != "Weekend"]<- "Weekday"
  active.df$weekend<- factor(active.df$weekend)
  return (active.df)
}

# Use the function to add a weekend column
imputed<- make.weekends(imputed)

# Make sure function worked with table()
table(imputed$weekend, imputed$weekday)
```



```{r fig.height=8, fig.width=13}
# 2.) Makes a panel plot containing a time series plot (i.e. type = "l") of the 5-minute interval (x-axis) and the average number of steps taken, averaged across all weekday days or weekend days (y-axis). 

make.weekend.ggplot<- function(active.dataframe){
  
  # Process intervals form integers into (00:00, 00:05, etc) format, and make as factors for plotting.
  
  active.dataframe$times<- as.factor(sprintf("%02d:%02d", active.dataframe$interval%/%100, active.dataframe$interval%%100) )
    
  #Transmform the data and get averages.
  
  active.intervals<- active.dataframe[ , mean(steps, na.rm = TRUE), by = list(weekend,times)]
  setnames(active.intervals, c("Weekend", "Interval", "Average"))
  print (active.intervals)
  #active.intervals<- cbind(active.intervals)
  ggplot(active.intervals, aes(x = Interval, y = Average, group = Weekend, color = Weekend)) + geom_line() +
    facet_grid(Weekend~.) +
    theme(axis.text.x=element_text(angle=270,hjust=1,vjust=0.5, size = 10)) + 
    scale_x_discrete(breaks = active.intervals$Interval[seq(1,288, by = 6)]) +
    ylab("Average steps") + 
    xlab("5-minute Time Intervals (Labeled in chunks of 30-minutes)") +
    theme(legend.position="none")
    #scale_x_discrete(breaks = active.intervals$Interval, labels=rep(times,2)) +
   # theme(axis.text.x=element_text(angle=90,hjust=1,vjust=0.5, size = 0.5))
}

make.weekend.ggplot(imputed)

# Here we can see the participant gets up around 5:30am on weekdays (presumably for work) and get takes by far the most steps of week on weekdays between 8:15am and 8:45am (maybe walking to work?). 

#On the weekends, activity is more sluggish until around 8:00am, but they are more active during the day on average.  

#Generally, by 20:00 (8pm) most activity has stopped on weekdays, while weekends show surges of activity 21:30 (9:30pm)


```


